{"version":3,"file":"static/js/30.a724cb46.chunk.js","mappings":"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","sources":["pages/Sudoku.js"],"sourcesContent":["import { useCallback, useEffect, useState } from \"react\";\n\nimport \"../styles/sudoku.css\";\n\nconst Sudoku = () => {\n\n    const [sudoku, setSudoku] = useState([]);\n    const [sudokuSolved, setSudokuSolved] = useState([]);\n    const [colors, setColors] = useState([]);\n    \n    const shuffle = useCallback((array) => {\n      let currentIndex = array.length;\n      let randomIndex;\n    \n      // While there remain elements to shuffle.\n      while (currentIndex !== 0) {\n    \n        // Pick a remaining element.\n        randomIndex = Math.floor(Math.random() * currentIndex);\n        currentIndex--;\n    \n        // And swap it with the current element.\n        [array[currentIndex], array[randomIndex]] = [\n          array[randomIndex], array[currentIndex]];\n      }\n    \n      return array;\n    }, []);\n\n    const findEmptyCell = useCallback((grid) => {\n      for (var row = 0; row < 9; row++) {\n        for (var col = 0; col < 9; col++) {\n          if (grid[row][col] === 0) {\n            return [row, col];\n          }\n        }\n      }\n      return [-1, -1];\n    }, []);\n\n    const isValidNumber = useCallback((grid, row, col, num) => {\n      for (var i = 0; i < 9; i++) {\n          if (grid[row][i] === num) {\n              return false;\n          }\n      }\n      \n      for (var j = 0; j < 9; j++) {\n        if (grid[j][col] === num) {\n          return false;\n        }\n      }\n  \n      var startRow = Math.floor(row / 3) * 3;\n      var startCol = Math.floor(col / 3) * 3;\n      for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n          if (grid[startRow + i][startCol + j] === num) {\n            return false;\n          }\n        }\n      }\n  \n      return true;\n  }, []);\n\n  const removeNumbers = useCallback((grid) => {\n    var emptyCells = 0;\n    var maxEmptyCells = 81 - 17;\n    \n    while (emptyCells < maxEmptyCells) {\n        var row = Math.floor(Math.random() * 9);\n        var col = Math.floor(Math.random() * 9);\n\n        if (grid[row][col] !== 0) {\n            grid[row][col] = 0;\n            emptyCells++;\n        }\n    }\n  }, []);\n  const solveSudoku = useCallback((grid) => {\n      var cell = findEmptyCell(grid);\n      var row = cell[0];\n      var col = cell[1];\n\n      if (row === -1) {\n        return true;\n      }\n      let values = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n      \n      values = shuffle(values);\n\n\n      for(let i = 0; i < values.length; i++){\n        let num = values[i];\n        if (isValidNumber(grid, row, col, num)) {\n          grid[row][col] = num;\n\n          if (solveSudoku(grid)) {\n            return true;\n          }\n      \n          grid[row][col] = 0;\n        }\n      }\n\n      return false;\n  }, [findEmptyCell, isValidNumber, shuffle]);\n\n  \n\n  const setSudokuValue = (row, col, value) => {\n      var newSudoku = sudoku;\n      newSudoku[row][col] = Number(value);\n      setSudoku(newSudoku);\n\n\n      if(parseInt(value) !== sudokuSolved[row][col]){\n        let newColors = colors;\n        newColors[row][col] = \"red\";\n        setColors(newColors);\n      }\n      else {\n        let newColors = colors;\n        newColors[row][col] = \"white\";\n        setColors(newColors);\n      }\n    };\n\n    const generateSudoku = useCallback(() => {\n\n        var grid = [];\n        for (var i = 0; i < 9; i++) {\n          grid[i] = [];\n          for (var j = 0; j < 9; j++) {\n            grid[i][j] = 0;\n          }\n        }\n      \n        solveSudoku(grid);\n\n        let newGrid = Array.from(grid, (arr) => [...arr]);\n\n        setSudokuSolved(newGrid);\n\n        removeNumbers(grid);\n\n        setSudoku(grid);\n    }, [solveSudoku, removeNumbers, setSudokuSolved, setSudoku]);\n\n    useEffect(() => {\n        generateSudoku();\n    }, [generateSudoku]);\n\n    useEffect(() => {\n      var colors = [];\n        for (var i = 0; i < 9; i++) {\n          colors[i] = [];\n          for (var j = 0; j < 9; j++) {\n            colors[i][j] = \"white\";\n          }\n        }\n        setColors(colors);\n    }, []);\n\n    return (\n        <div className=\"table\">\n            <div style={{color: \"white\", marginBottom: \"5rem\", textAlign: \"center\"}}>Sudoku</div>\n            <table className=\"table_1\">\n                <tbody>\n                    {sudoku.map((row, rowIndex) => {\n                        return (\n                            <tr key={rowIndex}>\n                                {row.map((cell, cellIndex) => {\n                                    if(cell === 0)\n                                    {\n                                        return (\n                                            <td key={cellIndex}><input type=\"number\" maxLength=\"1\" onChange={(e) => {\n                                              const val = e.target.value;\n                                              if(val.length > 1){\n                                                e.target.value = val.slice(0,1);\n                                              }\n                                              setSudokuValue(rowIndex, cellIndex, e.target.value)\n                                              e.target.style.color = colors[rowIndex][cellIndex];\n                                            }}/></td>\n                                        )\n                                    }\n                                    else{\n                                        return (\n                                            <td key={cellIndex}><div className=\"num\" style={{color:\"white\"}} key={cellIndex}>{cell}</div></td>\n                                        )\n                                    }\n                                })}\n                            </tr>\n                        );\n                    })}\n                </tbody>\n            </table>\n            <button className=\"button\" style={{margin: \"5vh\",alignSelf: \"center\", justifySelf:\"center\"}} onClick={() => {window.location.href = \"/#\"}}>Go Back</button>\n        </div>\n        \n    );\n}\n\nexport default Sudoku;"],"names":["_useState","useState","_useState2","_slicedToArray","sudoku","setSudoku","_useState3","_useState4","sudokuSolved","setSudokuSolved","_useState5","_useState6","colors","setColors","shuffle","useCallback","array","randomIndex","currentIndex","length","Math","floor","random","_ref","findEmptyCell","grid","row","col","isValidNumber","num","i","j","startRow","startCol","removeNumbers","emptyCells","solveSudoku","cell","values","generateSudoku","newGrid","Array","from","arr","_toConsumableArray","useEffect","_jsxs","className","children","_jsx","style","color","marginBottom","textAlign","map","rowIndex","cellIndex","type","maxLength","onChange","e","val","target","value","slice","newSudoku","Number","parseInt","newColors","setSudokuValue","margin","alignSelf","justifySelf","onClick","window","location","href"],"sourceRoot":""}